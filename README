INCLUDEPATH += /usr/local/include \
               /usr/local/include/opencv4 \
               /usr/local/include/opencv4/opencv2

LIBS += /usr/local/lib/libopencv_highgui.so \
        /usr/local/lib/libopencv_core.so    \
        /usr/local/lib/libopencv_imgproc.so \
        /usr/local/lib/libopencv_imgcodecs.so \
        /usr/local/lib/*.so

opencv_001:
	掩膜操作（提高对比度）
		手动掩膜
		使用fliter2D进行掩膜操作
	总结：filter2D效率更高。
opencv_002:
	Mat相关操作：
		拷贝，复制，Scalar，指针操作，色域转换，定义小矩阵
opencv_003:
	对像素点进行操作
opencv_004:
	addWeighted图像融合
opencv_005:
	对每个像素点进行修改，提高图像的亮度，或降低图像的亮度。
opencv_006:
	基本几何形状绘制，文字显示
opencv_007:
	blur均值模糊（滤波）：取所有像素的平均值赋值给当前像素
	GaussianBlur高斯模糊（滤波）：均值滤波的kernel值为
			[1,1,1]
			[1,1,1]
			[1,1,1]
			        高斯滤波的kernel值为
			x = -2 w = 0.05
			x = -1 w = 0.15
			x = 0  w = 0.6
			x = 1  w = 0.15
			x = 2  w = 0.05
opencv_008:
	medianBlur中值滤波：对椒盐噪声有很好的抑制作用
			对kernel覆盖的像素进行排序，把中间值赋值给中间像素，就会去除小的干扰
	bilateralFilter双边滤波 ：保留图像梯度（轮廓），当有边界时中心的像素值很大，周围的像素值很小，可能会覆盖掉像素的边界特征。双边滤波可以设置阈值，当超过阈值后，就保留当前的像素值，否则就进行高斯滤波。 
opencv_009:
	Mat kernel = getStructuringElement(int shape,Size ksize,Point anchor);
	腐蚀：数值小的像素取代数值大的像素（暗的像素变多）
	膨胀：数值大的像素取代数值小的像素（亮的像素变多）
opencv_010:
	形态学操作：
		膨胀，腐蚀
		形态学梯度（膨胀-腐蚀）
		开操作（先腐蚀后膨胀：去除小亮点）：先腐蚀去除小的亮点，大的要保留的亮色图像也会被深色覆盖部分，膨胀操作会使面积变小的亮色恢复原有大小。
		闭操作（先膨胀后腐蚀：去除小黑点）、
		顶帽（开操作-原图像）
		黑帽（闭操作-原图像）
opencv_011:
	形态学操作，提取水平与垂直线
	1、读取图像
	2、转为灰度图像
	3、转为二值图像（将要提取的线设置为前景色白色，背景为黑色）
	4、创建水平提取算子kernel_h，创建垂直提取算子kernel_v
	5、先腐蚀，后膨胀，或直接使用morphologyEx进行开操作。
opencv_012:
	上采样和降采样
	高斯不同（DOG）：对一个图像进行一次高斯滤波，得到g1，再对g1进行高斯滤波得到	g2，g1-g2结果就是DOG。subtract(g1,g2,output_image,Mat());
opencv_013:
	基本阈值操作
	阈值类型：
		5种阈值处理方法
		1、THRESH_BINARY阈值二值化
		2、THRESH_BINARY_INY阈值反二值化
		3、THRESH_TRUNC截断（超过阈值的设为阈值，没超过的保持不变）
		4、THRESH_TOZERO阈值取零（超过阈值的保持不变，没超过阈值的取0）
		5、THRESH_TOZERO_INV（超过阈值的取0，没超过阈值的保持不变）	
		2种阈值寻找方法
		THRESH_OTSU 自动寻找合适的阈值，设置的阈值不再起作用（不用手动设置阈值）
		用法：用|或运算符与5种方法中的一种配合使用
		THRESH_TRIANGLE反二值化阈值
opencv_014:
	自定义线性滤波：
		kernel中心位置就是锚点
		卷积如何工作：把kernel放到像素数组上，求锚点周围覆盖的像素乘积之和（包括锚点），用来替换锚点覆盖下的像素的值，称为卷积处理。    
		                                                                                       
		常见算子：
		Robert算子：
		[+1,  0
		    0,-1]
		[  0,+1
		  -1,  0]
		Sonel算子：
		[-1,0,1
		 -2,0,2
		 -1,0,1]
		[-1,-2,-1
		   0, 0, 0
		   1, 2, 1]
		拉普拉斯算子：
		[ 0,-1, 0
		 -1, 4,-1
		   0,-1,0]
		Sobel算子和拉普拉斯算子用来寻找图像的梯度和边缘。
opencv_015:
	处理边缘：
		BORDER_CONSTANT：填充边缘用指定像素值
		BORDER_REPLICATE：填充边缘像素用已知的边缘值
		BORDER_WRAP：用另外一边的像素值来补偿填充
	给图像添加边缘：
		copyMakeBorder(Mat src,Mat dst,int top,int bottom,int left,int right,int borderTpe,Scalar value)
		卷积操作的函数可以指定边缘填充的类型：
			GaussianBlur(src,dst,Size(3,3),0,0,BORDER_WRAP);
opencv_016:
	卷积应用：图像边缘提取，计算图像像素的分布，求一阶导数，导数最大的地方就是边缘。
	图像边缘提取：
		边缘是什么——是像素值发生跃迁的地方，是图像的显著特征之一，在图像特征提取、对象检测、模式识别等方面都有重要的作用。
		如何捕捉/提取边缘——对图像求一阶导数delta=f(x)-f(x-1)，delta越大，说明像素在X方向上变化越大，边缘信号越强。
	Sobel算子提取边缘：
		水平梯度：Gx = kernel_x*I
		垂直梯度：Gy = kernel_y*I
		最终梯度：
				G = Square(Gx2+Gy2) ===>L1
				G = |Gx| + |Gy|            ===>L2  近似求解，速度快
		Sobel(
			inputArray Src,
			outputArray dst,
			int depth,		// 图像深度，-1会自动设置
			int dx,			// x方向求导的阶数
			int dy,			// y方向求导的阶数
			int ksize,		// kernel的大小，必须是奇数。
			double scale = 1,	
			double delta = 0,
			int borderType = BORDE_DEFAULT
		)
	Laplance算子二阶求导获取图像边缘：
		一阶导数的极大值点是边界，在二阶导数中过0点。
		1、高斯模糊去噪声
		2、转换为灰度图像
		3、拉普拉斯二阶导数计算
		4、取绝对值
		5、显示结果
opencv_017:

	Canny边缘检测：
		算法介绍：共五步
			1、高斯模糊 GaussianBlur
			2、灰度转换 cvtColor
			3、计算梯度 Sobel/Scharr
			4、非最大信号抑制：根据比较方向比较当前像素与左右或上下元素的值，如果该值是最大值则保留，不是最大值则置0；
			5、高低阈值输出二值图像：T1，T2为阈值，凡是高于T1的都保留，凡是小于T2的都丢弃。从高于T1的像素出发，凡是大于T2而且相互连接的，都保留。最终输出二值图像。推荐高低阈值比为T1：T2 = 3:1 / 2:1,其中T1为高阈值，T2为低阈值。
		Canny(
			inputArray src,		// 输入8-bit图像（0-255）也就是灰度图像
			outputArray dst,		//输出边缘图像，一般为二值图像，背景是黑色
			double threshold1,		//低阈值
			double threshold2,		//高阈值（低阈值大2倍或3倍）
			int aptertureSize,		//Sobel算子的Size，通常是3*3，取值3
			bool L2gradient		// 选择true表示是L2来归一化，否则使用L1归一化
		)
opencv_018:
	霍夫变换——直线检测：
		对于所有给出的点，投影到极坐标上，r = xcosɵ+ysinɵ，根据不同的角度，可以得到一条曲线。每个点都能得到一条曲线，如果多个点投影的曲线交于一点，说明这些点在同一条直线上，根据ɵ，r可以推算出直线的位置。
	对于任意一条直线上的点来说，变换到极坐标中，从[0,360]空间，可以得到r的大小。属于同一条直线上的点在极坐标(r,ɵ)必然在一点上有最强的信号出现，根据此反算到平面坐标中就可以得到直线上各点的像素坐标。从而得到直线。
	如果把图像转换成二值图像，前景色为白色，投影到极坐标上，最白的点就是最强信号，在同一直线上的点的累加。
	HoughLines(
		inputArray src,
		outputArray lines,
		double rho,		//生层极坐标时，像素扫描的步长
		double theta,		//生成极坐标时，角度步长，一般取CV_PI/180.0
		int threshold,		//阈值，当点数超过该值时才被看做是直线
		…...
	) 输出（r,ɵ）
	HoughLinesP()输出直线（x0,y0,x1,y1）

	霍夫变换——圆检测：
		对一个像素点，根据r和 ɵ，逐步增加，多个相同大小的圆交于一点，说明这些像素在同于个圆上，交点就是圆的圆心
		HoughCircles(
			inputArray image,	// 8位灰度图像
			outputArray circles,	//输出发现结果
			int method,		// 方法-HOUGH_GRADIENT
			double dp,		// 1
			double mindist,	//10 最短距离-可以分辨是两个圆，否则认为是同心圆
			double param1,	//
			double param2,	//中心点累加阈值
			int minradius,		//最小半径
			int maxradius		//最大半径
		)
opencv_019:	
	remap：像素重映射
map_x.create(src.size(),CV_32FC1);
map_y.create(src.size(),CV_32FC1);
remap(src,dst,map_x,map_y,INTER_LINEAR,BORDER_CONSTANT,Scalar(0,255,0));
// remap的映射表
void update_map(){
    for(int row=0;row<src.rows;row++){
        for(int col=0;col<src.cols;col++){
            switch (num) {
            case 0:// 图像缩小为原来的二分之一，相当于降采样
                if(col>=src.cols*0.25&&col<=src.cols*0.75&&row>=src.rows*0.25&&row<=src.rows*0.75){// 在显示窗口的中心显示缩小后的图片，没有没有被图像覆盖的地方用0覆盖
                    // 保留偶数行和偶数列的像素
			  // 映射表里的元素是该位置应该对应原图像中像素的位置
                    map_x.at<float>(row,col) = 2*(col-src.cols*0.25);
                    map_y.at<float>(row,col) = 2*(row-src.rows*0.25);
                }else {
                    map_x.at<float>(row,col) = 0;
                    map_y.at<float>(row,col) = 0;
                }
                break;
            case 1:// 图像关于y轴翻转
                map_x.at<float>(row,col) = src.cols-col;
                map_y.at<float>(row,col) = row;
                break;
            case 2:// 图像关于x轴翻转
                map_x.at<float>(row,col) = col;
                map_y.at<float>(row,col) = src.rows-row;
                break;
            case 3:// 图像关于xy轴翻转
                map_x.at<float>(row,col) = src.cols-col;
                map_y.at<float>(row,col) = src.rows-row;
                break;
            }
        }
    }
}
opencv_020:
	直方图：对图像中的像素值进行统计，显示成直方图。
		直方图反应了图像灰度分布情况，是图像的统计学特征。
	直方图均衡化：是一种提高图像对比度的方法
			使用remap将图像灰度从一个分布映射到另一个分布。
			equalizeHist(src,dst);//输入为8位的单通道图像。
opencv_021:
	直方图计算：
		dims表示维度，对灰度图像来说只有一个通道，dims=1
		bins 表示在维度中子区域大小划分，bins=256，划分为256个级别
		range表示值的阈值，灰度值范围为[0,255]之间
	
	把多通道图像分为多个单通道图像,都是灰度图像，但灰度的值对应的是每个通道原有值的大小	
	split(
		const Mat& src,	// 输入图像
		Mat * mvbegin	// 输出图像数组
	)
	calcHist(
		const Mat* images,	// 输入图像指针
		int images,		//图像数目
		const int *channels, 	// 通道数
		inputArray mask,	// 输入mask，可选
		outputArray hist,	// 输出直方图数据
		int dims,		// 维数
		const int * histsize,	// 直方图级数
		const float* range,	// 值域范围
		bool uniform,		// true by default
		bool accumulate	// false by default
	)
	cvRound(float/double/int);//将浮点数四舍五入到最接近的整数
	
	normalize：
	
void cv::normalize 
(
InputArray src, 
InputOutputArray dst, 
double alpha = 1, 
double beta = 0, 
int norm_type = NORM_L2, 
int dtype = -1, 
InputArray mask = noArray() 
)


Python:dst=cv.normalize(src, dst[, alpha[, beta[, norm_type[, dtype[, mask]]]]])

#include <opencv2/core.hpp>
Normalizes the norm or value range of an array. 
The function cv::normalize normalizes scale and shift the input array elements so that 
∥dst∥Lp=alpha
(where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that 
minIdst(I)=alpha,maxIdst(I)=beta
when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or min-max but modify the whole array, you can use norm and Mat::convertTo.
In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this, the range transformation for sparse matrices is not allowed since it can shift the zero level.
Possible usage with some positive example data: 
vector<double> positiveData = { 2.0, 8.0, 10.0 };
vector<double> normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;
// Norm to probability (total count)
// sum(numbers) = 20.0
// 2.0 0.1 (2.0/20.0)
// 8.0 0.4 (8.0/20.0)
// 10.0 0.5 (10.0/20.0)
normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);
// Norm to unit vector: ||positiveData|| = 1.0
// 2.0 0.15
// 8.0 0.62
// 10.0 0.77
normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);
// Norm to max element
// 2.0 0.2 (2.0/10.0)
// 8.0 0.8 (8.0/10.0)
// 10.0 1.0 (10.0/10.0)
normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);
// Norm to range [0.0;1.0]
// 2.0 0.0 (shift to left border)
// 8.0 0.75 (6.0/8.0)
// 10.0 1.0 (shift to right border)
normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX);
Parameters
src input array. 
dst output array of the same size as src . 
alpha norm value to normalize to or the lower range boundary in case of the range normalization.在范围归一化的情况下，要归一化到下限边界的标准值。 
beta upper range boundary in case of the range normalization; it is not used for the norm normalization. 范围归一化的情况下的范围上限; 它不用于规范归一化。
norm_type normalization type (see cv::NormTypes). 
dtype when negative, the output array has the same type as src; otherwise, it has the same number of channels as src and the depth =CV_MAT_DEPTH(dtype). 
mask optional operation mask. 

